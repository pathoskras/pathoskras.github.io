// From http://bl.ocks.org/nitaku/d79632a53187f8e92b15/dc1b22049eed0a4922bf093e85601de053b37dc5
// Generated by CoffeeScript 1.4.0
// https://observablehq.com/@d3/draw-me

const SWATCH_D = 22

const renderLine = d3.line().x(function (d) {
  return d[0]
}).y(function (d) {
  return d[1]
}).curve(d3.curveBasis)

type DrawingData = {
  id: number;
  image: string;
  lines: any[];
  name: string;
  legend: string;
}

type DrawnLine = {
  points: [number, number][];
  color: string;
  elem ?: any;
}

class Drawer {
  backgroundImage: string;
  id: number;
  image: string;
  // lines: any[];
  name: string;
  legend: string;

  linesLayer :any;
  backgroundImageGroup :any;

  drawingData = { // eslint-disable-line
    lines: []
  }

  activeLine = null
  activeColor = '#333333'

  constructor (data : DrawingData) {
    this.id = data.id
    this.drawingData.lines = data.lines
    this.name = data.name
    this.image = data.image
    this.legend = data.legend
  }

  getDrawingData () {
    return {
      id: this.id,
      image: this.image,
      name: this.name,
      legend: this.legend,
      lines: this.drawingData.lines
    }
  }

  getLines () {
    return this.drawingData.lines.map(d => {
      return {
        points: d.points,
        color: d.color
      }
    })
  }

  closeDrawer () {
    d3.select('#d3-drawer svg').remove()
  }

  showDrawer () {
    const drawer = this
    const canvas = d3.select('#d3-drawer').append('svg').attrs({
      id: 'canvas',
      viewBox: '0,0,960,610'
    })

    this.backgroundImageGroup = canvas.append('g').attrs({
      id: 'backgroundImageGroup'
    }).append('image').attrs({
      id: 'd3-background-image',
      width: 960,
      height: 600,
      y: 10,
      href: `/images/${this.image}`
    })

    const ui = canvas.append('g').attrs({
      id: 'drawer-ui'
    })

    drawer.drawUI(ui)

    this.linesLayer = canvas.append('g').attrs({
      id: 'linesLayer'
    })

    const drag = d3.drag()

    drag.on('start', function (this :d3.ContainerElement) {
      drawer.activeLine = {
        points: [],
        color: drawer.activeColor
      }
      drawer.drawingData.lines.push(drawer.activeLine)
      return drawer.redraw(drawer.activeLine)
    })

    drag.on('drag', function (this :d3.ContainerElement) {
      drawer.activeLine.points.push(d3.mouse(this).map(d => Math.floor(d)))
      return drawer.redraw(drawer.activeLine)
    })

    drag.on('end', function () {
      if (drawer.activeLine.points.length === 0) {
        drawer.drawingData.lines.pop()
      }
      drawer.activeLine = null
      return console.log(drawer.drawingData)
    })

    this.backgroundImageGroup.call(drag)

    this.paintLines()
  }

  /**
   * Erase & redraw the lines.
   */
  paintLines (drawingData ?: DrawingData) {
    const drawingLines :DrawnLine[] = drawingData ? drawingData.lines : this.drawingData.lines

    d3.selectAll('#canvas g .line').remove()
    const lines = d3.select('#canvas g')
      .selectAll('.line')
      .data(drawingLines)
      .enter().append('path').attrs({
        class: 'line',
        stroke: function (d :DrawnLine) {
          return d.color
        },
        d: function (d :DrawnLine) {
          return renderLine(d.points)
        }
      }).each(function (d: DrawnLine) {
        d.elem = d3.select(this)
        return d.elem
      })
    return lines.exit().remove()
  }

  drawImage = function () {
    console.log('drawing image')
  }

  drawUI = function (ui) {
    const drawer = this
    const palette = ui.append('g').attrs({
      transform: 'translate(' + (4 + SWATCH_D / 2) + ',' + (4 + SWATCH_D / 2) + ')'
    })

    const swatches = palette.selectAll('.swatch')
      .data(['#333333', '#ffffff', '#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'])
      .enter().append('circle').attrs({
        stroke: 'grey',
        class: 'swatch',
        cx: function (d, i) {
          return i * (SWATCH_D + 4) / 2
        },
        cy: function (d, i) {
          if (i % 2) {
            return SWATCH_D
          } else {
            return 0
          }
        },
        r: SWATCH_D / 2,
        fill: function (d) {
          return d
        }
      }).on('click', function (d) {
        drawer.activeColor = d
        palette.selectAll('.swatch').classed('active', false)
        return d3.select(this).classed('active', true)
      })

    swatches.each(function (d, i, arr) {
      if (d === drawer.activeColor) {
        return d3.select(arr[i]).classed('active', true)
      }
    })

    /*
    d3.select("#d3-drawer").append('input').attrs({
      name: "asdf",
      type: "range",
      min: 0.5,
      max: 20,
      value: 1,
      step: 0.5,
      style: "width:120px"
    }).append("div").append("div").attrs({
      pseudo: "-webkit-slider-runnable-track",
      id: "track"
    }).append("div").attrs({
      id: "thumb"
    })
*/

    const trashBtn = ui.append('text')
      .text('\uf1f8')
      .classed('btn', true)
      .attrs({
        dy: '0.35em',
        transform: 'translate(940,20)'
      }).on('click', function () {
        drawer.drawingData.lines = []
        return drawer.paintLines()
      })
  }

  redraw = function (specificLine ?: DrawnLine) {
    const lines = this.linesLayer.selectAll('.line')
      .data(this.drawingData.lines)
      .enter()
      .append('path')
      .attrs({
        class: 'line',
        stroke: function (d) {
          return d.color
        }
      }).each(function (d) {
        d.elem = d3.select(this)
        return d.elem
      })
    if (specificLine && specificLine.elem) {
      specificLine.elem.attrs({
        d: function (d) {
          return renderLine(d.points)
        }
      })
    } else {
      lines.attrs({
        d: function (d) {
          return renderLine(d.points)
        }
      })
    }
    return lines.exit().remove()
  }
}
